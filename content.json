{"meta":{"title":"TechPuthon","subtitle":"Puthon's  Technology  Sharing Blog","description":null,"author":"TechPuthon","url":"http://yoursite.com","root":"/"},"pages":[{"title":"文章标签","date":"2020-03-14T03:17:43.000Z","updated":"2020-03-15T03:43:23.218Z","comments":false,"path":"tags/index.html","permalink":"http://yoursite.com/tags/index.html","excerpt":"","text":""},{"title":"关于","date":"2020-03-14T03:17:21.000Z","updated":"2020-03-14T12:46:36.392Z","comments":true,"path":"about/index.html","permalink":"http://yoursite.com/about/index.html","excerpt":"","text":"初心热爱技术，热爱折腾，纵使荆棘遍地，筚路蓝缕，依旧敝履以往 技术域 编程算法 Linux 单片机 生活域世界很大，风景很美"},{"title":"文章分类","date":"2020-03-14T03:07:51.000Z","updated":"2020-03-15T03:43:26.264Z","comments":false,"path":"categories/index.html","permalink":"http://yoursite.com/categories/index.html","excerpt":"","text":""}],"posts":[{"title":"树莓派装机","slug":"5- 树莓派装机","date":"2020-03-14T04:12:57.000Z","updated":"2020-03-15T07:03:00.901Z","comments":true,"path":"2020/03/14/5- 树莓派装机/","link":"","permalink":"http://yoursite.com/2020/03/14/5-%20%E6%A0%91%E8%8E%93%E6%B4%BE%E8%A3%85%E6%9C%BA/","excerpt":"","text":"","categories":[{"name":"树莓派","slug":"树莓派","permalink":"http://yoursite.com/categories/%E6%A0%91%E8%8E%93%E6%B4%BE/"}],"tags":[{"name":"树莓派","slug":"树莓派","permalink":"http://yoursite.com/tags/%E6%A0%91%E8%8E%93%E6%B4%BE/"},{"name":"装机","slug":"装机","permalink":"http://yoursite.com/tags/%E8%A3%85%E6%9C%BA/"},{"name":"B站","slug":"B站","permalink":"http://yoursite.com/tags/B%E7%AB%99/"}]},{"title":"2020树莓派十佳项目集锦","slug":"6- 2020树莓派十佳项目集锦","date":"2020-03-14T04:12:57.000Z","updated":"2020-03-15T07:03:02.254Z","comments":true,"path":"2020/03/14/6- 2020树莓派十佳项目集锦/","link":"","permalink":"http://yoursite.com/2020/03/14/6-%202020%E6%A0%91%E8%8E%93%E6%B4%BE%E5%8D%81%E4%BD%B3%E9%A1%B9%E7%9B%AE%E9%9B%86%E9%94%A6/","excerpt":"","text":"","categories":[{"name":"树莓派","slug":"树莓派","permalink":"http://yoursite.com/categories/%E6%A0%91%E8%8E%93%E6%B4%BE/"}],"tags":[{"name":"树莓派","slug":"树莓派","permalink":"http://yoursite.com/tags/%E6%A0%91%E8%8E%93%E6%B4%BE/"},{"name":"B站","slug":"B站","permalink":"http://yoursite.com/tags/B%E7%AB%99/"},{"name":"集锦","slug":"集锦","permalink":"http://yoursite.com/tags/%E9%9B%86%E9%94%A6/"}]},{"title":"树莓派3B开箱","slug":"5- 树莓派开箱","date":"2020-02-23T04:12:57.000Z","updated":"2020-03-15T07:02:59.373Z","comments":true,"path":"2020/02/23/5- 树莓派开箱/","link":"","permalink":"http://yoursite.com/2020/02/23/5-%20%E6%A0%91%E8%8E%93%E6%B4%BE%E5%BC%80%E7%AE%B1/","excerpt":"","text":"","categories":[{"name":"树莓派","slug":"树莓派","permalink":"http://yoursite.com/categories/%E6%A0%91%E8%8E%93%E6%B4%BE/"}],"tags":[{"name":"树莓派","slug":"树莓派","permalink":"http://yoursite.com/tags/%E6%A0%91%E8%8E%93%E6%B4%BE/"},{"name":"B站","slug":"B站","permalink":"http://yoursite.com/tags/B%E7%AB%99/"},{"name":"开箱","slug":"开箱","permalink":"http://yoursite.com/tags/%E5%BC%80%E7%AE%B1/"}]},{"title":"柔性数组应用","slug":"1- 柔性数组","date":"2019-10-29T04:42:57.000Z","updated":"2020-03-14T09:26:35.025Z","comments":true,"path":"2019/10/29/1- 柔性数组/","link":"","permalink":"http://yoursite.com/2019/10/29/1-%20%E6%9F%94%E6%80%A7%E6%95%B0%E7%BB%84/","excerpt":"首先我们来看一道面试题如果你还不能很快就得出答案，那可以通过本次的介绍彻底的了解一下“柔性数组”参考答案会在文末给出哦！","text":"首先我们来看一道面试题如果你还不能很快就得出答案，那可以通过本次的介绍彻底的了解一下“柔性数组”参考答案会在文末给出哦！ 开发C代码时,经常见到如下类型的结构体定义: 12345typedef struct list_t&#123;struct list_t *next;struct list_t *prev;char data[0];&#125;list_t; 最后一行char data[0];的作用是（） A、方便管理内存缓冲区 B、减少内存碎片化 C、标识结构体结束 D、没有作用 柔性数组是C99引入的一个新特性这个特性允许你在定义结构体的时候创建一个空数组，而这个数组的大小可以在程序运行的过程中根据你的需求进行更改特别注意的一点是：这个空数组必须声明为结构体的最后一个成员，并且还要求这样的结构体至少包含一个成员上面的简答介绍可能还是没能足够让你了解什么是“柔性数组”，以及具体又该如何使用，下面就通过具体的例子进行解释： 现在我们需要进行学生的一些基本信息的统计，假设我们定义了如下的一个结构体： 123456typedef struct&#123; int stuID; int name; char address[30];&#125;ST_STU_INFO; 可以看到在最后存储“地址（address）“的结构体中，我们申请了一个30个字节的数组，如果我们存储的时候只存入较短的地址以上的定义的是没问题的，但需要存入的地址信息超出了30个字节，程序很可能就崩掉了，就像下面这样 这时候具有主角光环的柔性数组就可以登场啦！我们在结构体中定义一个柔性数组，这样可以确保能够在程序运行过程中“动态”的进行结构体的扩展，好像是有点动态的感觉了呀！具体代码如下： 12345678910111213141516171819202122232425262728293031323334353637383940414243#include&lt;stdio.h&gt;//存放学生信息结构体typedef struct&#123; int stuID; int age; char address[];&#125;ST_STU_INFO,*pStuInfo;//为结构体分配内存pStuInfo ComposeStuInfo( int stuID,int age, const char *paddress)&#123; pStuInfo ptmpInfo = malloc(sizeof(*ptmpInfo) + sizeof(char) * strlen(paddress) + 1); if(ptmpInfo != NULL)&#123; ptmpInfo-&gt;stuID = stuID; ptmpInfo-&gt;age = age; strcpy(ptmpInfo-&gt;address, paddress); &#125; return ptmpInfo;&#125;// 打印学生信息void printStuInfo(pStuInfo ptmpInfo)&#123; printf(\"stuID : %d age : %d Address: %s\\nSize of Struct：%d\\n\\n\", ptmpInfo-&gt;stuID,ptmpInfo-&gt;age,ptmpInfo-&gt;address,sizeof(*ptmpInfo));&#125;//主程序int main()&#123; pStuInfo CodeLab = ComposeStuInfo(100013,20, \"Tencent Building, Central District, High-tech Park, Nanshan District, Shenzhen\"); if(CodeLab != NULL)&#123; printStuInfo(CodeLab); free(CodeLab); &#125; pStuInfo subCodeLab = ComposeStuInfo(200013,23, \"Tencent Building\");//Tencent Building里面的大佬个个都很厉害吧~~~ if(subCodeLab != NULL)&#123; printStuInfo(subCodeLab); free(subCodeLab); &#125; return 0;&#125; 运行之后得到结果如下： 12345stuID : 100013 age : 20 Address: Tencent Building, Central District, High-tech Park, Nanshan District, ShenzhenSize of Struct：8stuID : 200013 age : 23 Address: Tencent BuildingSize of Struct：8 从结果输出可以看到，我们成功使用了不同长度的地址，当然程序也不会出现文章开头那样崩溃的情况 此外，虽然我们对结构体进行了如下的初始化 1pStuInfo ptmpInfo = malloc(sizeof(*ptmpInfo) + sizeof(char) * strlen(paddress) + 1); 但是却在输出中可以看到结构体的大小并没有因此而发生变化Size of Struct：8 ST_STU_INFO结构体的大小是8， 两个int型变量大小刚好为8，也就是说结构体中的数组并没有占用内存 针对柔性数组这一不占用内存的特性，可以构造出内存缓冲区，同时由于是使用多少就申请多少，也起到了减少内存碎片化的作用，所以文章开头的面试题答案是A和B 而对于选项C而言，恰恰相反的是，柔性数组并不是标识结构体结束，而是作为结构体的一种拓展 同时也可以理解为柔性数组为结构体的一个偏移地址，这使得结构体的大小可以进行动态的变化 最后可能还是会有疑问，这和直接使用指针有啥区别呢？ 12345typedef struct&#123; int stuID; int age; char *pAddress;&#125;ST_STU_INFO; 首先柔性数组不占用内存，而指针则不然，此外柔性数组在使用上是直接访问，形式上更加直观，而指针需要经过声明再进行动态分配内存，在效率上和柔性数组相比也稍微低一些 在Linux内核代码中有较多的柔性数组的使用，如果想再深入的了解可以在跳表（Skip List）的实现中加以运用 https://gcc.gnu.org/onlinedocs/gcc/Zero-Length.html http://elkpi.com/topics/2014/07/zero-length-arrays.html https://blog.csdn.net/gatieme/article/details/64131322","categories":[{"name":"编程基础","slug":"编程基础","permalink":"http://yoursite.com/categories/%E7%BC%96%E7%A8%8B%E5%9F%BA%E7%A1%80/"}],"tags":[{"name":"C/C++","slug":"C-C","permalink":"http://yoursite.com/tags/C-C/"},{"name":"编程基础","slug":"编程基础","permalink":"http://yoursite.com/tags/%E7%BC%96%E7%A8%8B%E5%9F%BA%E7%A1%80/"}]},{"title":"精简if-else结构","slug":"2- 如何精简ifelse","date":"2019-10-29T04:12:57.000Z","updated":"2020-03-14T09:28:11.086Z","comments":true,"path":"2019/10/29/2- 如何精简ifelse/","link":"","permalink":"http://yoursite.com/2019/10/29/2-%20%E5%A6%82%E4%BD%95%E7%B2%BE%E7%AE%80ifelse/","excerpt":"在平时的开发过程中一定会遇到使用 if-else 分支结构的情况有时候确实无法避免，但有一些特定的场合我们可以合理的运用一些技巧来为代码瘦身，下面就通过本文来做一个详细的了解吧！","text":"在平时的开发过程中一定会遇到使用 if-else 分支结构的情况有时候确实无法避免，但有一些特定的场合我们可以合理的运用一些技巧来为代码瘦身，下面就通过本文来做一个详细的了解吧！ 1- 卫语句（提前return）卫语句(Guard clause)指的是在遇到异常情况时，提前进行抛出，这在一定程度上可以减少if-else分支结构的使用，可以在逻辑性和代码简洁性上得到提高 在阿里巴巴与Java社区开发者制定的《Java开发手册(华山版)》中有对控制语句的编程规约有如下的建议： 再来看下面这段代码，在条件为真的情况下我们执行相关的业务代码，否则抛出异常 123456789void Demo(...)&#123; if (true_to_continue)&#123; ... //20行业务代码 &#125; else&#123; throw new SomeException(); &#125;&#125; 如果我们将if内的条件进行反转之后，同样的功能，但是我们减少了else的使用 1234567void Demo(...)&#123; if (!true_to_continue)&#123; throw new SomeException(); &#125; ... //20行业务代码&#125; 2- map映射比如我们将英文单词转为化为对应的数字，如果用if-else分支结构可能会写成下面的代码： 1234567int ConvertStr2Num(string strin)&#123; if(strin == \"one\") return 1; else if(strin == \"two\") return 2; else if(strin == \"three\") return 3; //其余的情况... return 0;&#125; 这样看起来我们的代码会显得很冗长，在C++里面我们可以借助map来实现，即我们预先将逻辑分支的信息存储到map中，之后通过对键值的读取来获得相应的输出 1234567891011int ConvertStr2Num(string strin) &#123; static const map&lt;string, int&gt; wordmap = &#123; &#123;\"one\", 1&#125;, &#123;\"two\", 2&#125;, &#123;\"three\",3&#125; // 其余的情况... &#125;; const auto result = wordmap.find(strin); if (result == wordmap.end()) return 0; return result-&gt;second;&#125; 当然对于map我们也可以使用数组或者结构体等来实现相同的功能 3- 三元运算符三元运算符使用的基本结构如下 [条件语句] ? [表达式1] : [表达式2] 这个大家可能都比较熟悉了，比如比较两个数的大小的时候可以为了简化if-else分支结构采用三元运算符进行替换，这里还值得注意的是，如果结合宏函数使用效果可能更好 1#define MAX(a,b) (((a)&gt;(b))?(a):(b)) 4-利用继承和多态对于减少if-else分支结构的使用的方法不得不提的就是面向对象的编程 关于小猫小狗的一段程序如下 12345678if (animal.IsDog)&#123;//狗 animal.EatCookie(); animal.Bark();&#125;else &#123;//猫 animal.EatFishs(); animal.Meow();&#125; 在面向对象的编程过程中，我们只关心接口是什么，具体的实现我们并不关心，所以我们可以创建两个子类分别表示Cat和Dog，具体的实现方法放在子类中完成 12345678910111213141516171819class Animal &#123;public: virtual void MakeSound(); virtual void Eat();&#125;;class Cat: public Animal &#123;public: void MakeSound() &#123; cout&lt;&lt;\"meow\"&lt;&lt;endl; &#125;&#125;;class Dog : public Animal &#123;public: void MakeSound() &#123; cout&lt;&lt;\"bark\"&lt;&lt;endl; &#125;&#125;; 最后，愿你写出优雅的代码！","categories":[{"name":"编程基础","slug":"编程基础","permalink":"http://yoursite.com/categories/%E7%BC%96%E7%A8%8B%E5%9F%BA%E7%A1%80/"}],"tags":[{"name":"C/C++","slug":"C-C","permalink":"http://yoursite.com/tags/C-C/"},{"name":"编程基础","slug":"编程基础","permalink":"http://yoursite.com/tags/%E7%BC%96%E7%A8%8B%E5%9F%BA%E7%A1%80/"}]},{"title":"Qt调用cmd并执行ping命令","slug":"4- QT调用外部exe并互相传递参数","date":"2019-04-24T04:12:57.000Z","updated":"2020-03-14T09:28:11.100Z","comments":true,"path":"2019/04/24/4- QT调用外部exe并互相传递参数/","link":"","permalink":"http://yoursite.com/2019/04/24/4-%20QT%E8%B0%83%E7%94%A8%E5%A4%96%E9%83%A8exe%E5%B9%B6%E4%BA%92%E7%9B%B8%E4%BC%A0%E9%80%92%E5%8F%82%E6%95%B0/","excerpt":"1-外部exe程序接受输入参数以下是需要调用的exe程序的源码，主要思路就是获取QT输入的参数，当输入参数为1是时便输出Hello CodeLab!这里主要要关注一下int argc, char* argv[]这两个参数，其中argc表示的是输入参数的个数， argv[]则表示输入的具体参数，要注意的是默认会输入一个exe程序文件路径的参数，所以自定义参数下标是从1开始的。","text":"1-外部exe程序接受输入参数以下是需要调用的exe程序的源码，主要思路就是获取QT输入的参数，当输入参数为1是时便输出Hello CodeLab!这里主要要关注一下int argc, char* argv[]这两个参数，其中argc表示的是输入参数的个数， argv[]则表示输入的具体参数，要注意的是默认会输入一个exe程序文件路径的参数，所以自定义参数下标是从1开始的。 123456789101112#include &lt;iostream&gt;int main(int argc, char* argv[]) &#123; std::cout &lt;&lt; &lt;&lt;argc &lt;&lt; std::endl;//输出参数的个数 for(int i = 0;i&lt;argc;i++)&#123; std::cout&lt;&lt;argv[i]&lt;&lt;std::endl;//输出具体参数 &#125; if(*argv[1] == '1')&#123;//提取第一个参数， std::cout &lt;&lt; \"Hello CodeLab!\" &lt;&lt; std::endl; &#125; return 0;&#125; 2-QT输出参数到exe并接收参数显示源码如下： 1234567891011121314151617181920212223242526272829303132333435#include \"mainwindow.h\"#include \"ui_mainwindow.h\"#include &lt;qdebug.h&gt;#include &lt;qprocess.h&gt;MainWindow::MainWindow(QWidget *parent) : QMainWindow(parent), ui(new Ui::MainWindow)&#123; ui-&gt;setupUi(this);&#125;MainWindow::~MainWindow()&#123; delete ui;&#125;void MainWindow::on_btnPing_clicked()&#123; qDebug()&lt;&lt;QStringLiteral(\"开始点击\"); ui-&gt;textBrowser-&gt;clear(); ui-&gt;textBrowser-&gt;setText(QStringLiteral(\"请等待\")); ui-&gt;textBrowser-&gt;update(); QProcess myProcess(this); QString program = \"C:\\\\test.exe\"; QStringList arguments; arguments&lt;&lt;\"1\";//传递到exe的参数 myProcess.start(program,arguments); while (myProcess.waitForFinished(100) == false) &#123; QByteArray qByteRead = myProcess.readAllStandardOutput(); if (!qByteRead.isEmpty()) &#123; ui-&gt;textBrowser-&gt;append(QString::fromLocal8Bit(qByteRead)); repaint(); &#125; &#125; QByteArray qByteRead = myProcess.readAllStandardOutput(); ui-&gt;textBrowser-&gt;append(QString::fromLocal8Bit(qByteRead)); qDebug()&lt;&lt;QString::fromLocal8Bit(qByteRead); qDebug()&lt;&lt;\"结束点击\";&#125; 运行QT界面并点击ping可以得到如下的结果：","categories":[{"name":"QT","slug":"QT","permalink":"http://yoursite.com/categories/QT/"}],"tags":[{"name":"C/C++","slug":"C-C","permalink":"http://yoursite.com/tags/C-C/"},{"name":"QT","slug":"QT","permalink":"http://yoursite.com/tags/QT/"}]},{"title":"Qt调用cmd并执行ping命令","slug":"3- QT调用cmd并执行ping命令","date":"2019-03-26T04:12:57.000Z","updated":"2020-03-14T09:28:52.633Z","comments":true,"path":"2019/03/26/3- QT调用cmd并执行ping命令/","link":"","permalink":"http://yoursite.com/2019/03/26/3-%20QT%E8%B0%83%E7%94%A8cmd%E5%B9%B6%E6%89%A7%E8%A1%8Cping%E5%91%BD%E4%BB%A4/","excerpt":"1-问题描述在实现QT调用外部程序cmd.exe的时候传回来的参数需要显示在textbrowser控件上，但是一直等待数据全部接受完毕会才显示，会导致页面卡死的假象，所以下面利用append()进行每次都更新，可以很好的解决这个问题。","text":"1-问题描述在实现QT调用外部程序cmd.exe的时候传回来的参数需要显示在textbrowser控件上，但是一直等待数据全部接受完毕会才显示，会导致页面卡死的假象，所以下面利用append()进行每次都更新，可以很好的解决这个问题。 2-解决方案123456789101112131415161718192021222324252627282930313233343536373839//mainwindow.cpp文件，主界面实现#include \"mainwindow.h\"#include \"ui_mainwindow.h\"#include &lt;qdebug.h&gt;#include &lt;qprocess.h&gt;MainWindow::MainWindow(QWidget *parent) : QMainWindow(parent), ui(new Ui::MainWindow)&#123; ui-&gt;setupUi(this);&#125;MainWindow::~MainWindow()&#123; delete ui;&#125;void MainWindow::on_btnPing_clicked()&#123; qDebug()&lt;&lt;QStringLiteral(\"开始点击\"); ui-&gt;textBrowser-&gt;clear(); ui-&gt;textBrowser-&gt;setText(QStringLiteral(\"请等待\")); ui-&gt;textBrowser-&gt;update(); QProcess myProcess(this); QString program = \"C:/Windows/System32/cmd.exe\"; QStringList arguments; arguments &lt;&lt;\"/c\" &lt;&lt;\"ping www.baidu.com\"; myProcess.start(program,arguments); while (myProcess.waitForFinished(100) == false) &#123; QByteArray qByteRead = myProcess.readAllStandardOutput(); if (!qByteRead.isEmpty()) &#123; ui-&gt;textBrowser-&gt;append(QString::fromLocal8Bit(qByteRead)); repaint(); &#125; &#125; QByteArray qByteRead = myProcess.readAllStandardOutput(); ui-&gt;textBrowser-&gt;append(QString::fromLocal8Bit(qByteRead)); qDebug()&lt;&lt;QString::fromLocal8Bit(qByteRead); qDebug()&lt;&lt;\"结束点击\";&#125; 下面是会假死的方式 12345678QProcess myProcess(this);QString program = \"C:/Windows/System32/cmd.exe\";QStringList arguments;arguments &lt;&lt;\"/c\" &lt;&lt;\"ping www.baidu.com\";myProcess.start(program,arguments);myProcess.waitForFinished();QString qstr = QString::fromLocal8Bit(myProcess.readAllStandardOutput());ui-&gt;textBrowser-&gt;setText(qstr);","categories":[{"name":"QT","slug":"QT","permalink":"http://yoursite.com/categories/QT/"}],"tags":[{"name":"C/C++","slug":"C-C","permalink":"http://yoursite.com/tags/C-C/"},{"name":"QT","slug":"QT","permalink":"http://yoursite.com/tags/QT/"}]}]}